### 第 8 题：setTimeout、Promise、Async/Await 的区别

答案：

> setTimeout方法用于在指定的毫秒数后调用函数或计算表达式。
setTimeout它会开启一个定时器线程，并不会影响后续的代码执行，这个定时器线程会在事件队列后面添加一个任务，
当js线程在主线程执行其他线程代码完毕后，就会取出事件队列中的事件进行执行，
2.定时器中的this存在隐式丢失的情况
```
var a = 0;
function foo(){
    console.log(this.a);
};
var obj = {
    a : 2,
    foo:foo
}
setTimeout(obj.foo,100);//0
```
若想获得obj对象中的a属性值，可以将obj.foo函数放置在定时器中的匿名函数中进行隐式绑定
```
var a = 0;
function foo(){
    console.log(this.a);
};
var obj = {
    a : 2,
    foo:foo
}
setTimeout(function(){
    obj.foo();
},100);//2
```
或者使用bind方法将foo()方法的this绑定到obj上,call,apply方法均可
```
var a = 0;
function foo(){
    console.log(this.a);
};
var obj = {
    a : 2,
    foo:foo
}
setTimeout(obj.foo.bind(obj),100);//2
```
> promise就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果,将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数
Promise 新建后立即执行,promise提供promise.all,promise.race,promise.resolve,promise.rejecr等方法




不同点：
promise异步操作以同步操作的流程表达出来,
then和settimeout执行顺序，即setTimeout(fn, 0)在下一轮“事件循环”开始时执行，Promise.then()在本轮“事件循环”结束时执行。因此then 函数先输出，settimeout后输出。
例子：
```
var p1 = new Promise(function(resolve, reject){
    resolve(1);
})
setTimeout(function(){
  console.log("will be executed at the top of the next Event Loop");
},0)
p1.then(function(value){
  console.log("p1 fulfilled");
})
setTimeout(function(){
  console.log("will be executed at the bottom of the next Event Loop");
},0)
p1 fulfilled
will be executed at the top of the next Event Loop
will be executed at the bottom of the next Event Loop
```
原因：
JavaScript将异步任务分为MacroTask和MicroTask，
MacroTask包含MacroTask Queue（宏任务队列）主要包括setTimeout,setInterval, setImmediate, requestAnimationFrame, NodeJS中的I/O等。
MicroTask包含独立回调microTask：如Promise，其成功／失败回调函数相互独立；复合回调microTask：如 Object.observe, MutationObserver 和NodeJs中的 process.nextTick ，不同状态回调在同一函数体；
js执行顺序

>依次执行同步代码直至执行完毕；
>检查MacroTask 队列，若有触发的异步任务，则取第一个并调用其事件处理函数，然后跳至第三步，若没有需处理的异步任务，则直接跳至第三步；
>检查MicroTask队列，然后执行所有已触发的异步任务，依次执行事件处理函数，直至执行完毕，然后跳至第二步，若没有需处理的异步任务中，则直接返回第二步，依次>执行后续步骤；
>最后返回第二步，继续检查MacroTask队列，依次执行后续步骤；
>如此往复，若所有异步任务处理完成，则结束；










