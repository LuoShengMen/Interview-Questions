### 第 8 题：setTimeout、Promise、Async/Await 的区别

答案：

- setTimeout方法用于在指定的毫秒数后调用函数或计算表达式。
> * 1.setTimeout它会开启一个定时器线程，并不会影响后续的代码执行，这个定时器线程会在事件队列后面添加一个任务，
当js线程在主线程执行其他线程代码完毕后，就会取出事件队列中的事件进行执行，
> * 2.定时器中的this存在隐式丢失的情况
```
var a = 0;
function foo(){
    console.log(this.a);
};
var obj = {
    a : 2,
    foo:foo
}
setTimeout(obj.foo,100);//0
```
若想获得obj对象中的a属性值，可以将obj.foo函数放置在定时器中的匿名函数中进行隐式绑定
```
var a = 0;
function foo(){
    console.log(this.a);
};
var obj = {
    a : 2,
    foo:foo
}
setTimeout(function(){
    obj.foo();
},100);//2
```
或者使用bind方法将foo()方法的this绑定到obj上,call,apply方法均可
```
var a = 0;
function foo(){
    console.log(this.a);
};
var obj = {
    a : 2,
    foo:foo
}
setTimeout(obj.foo.bind(obj),100);//2
```
- promise就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果,将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数
Promise 新建后立即执行,promise提供promise.all,promise.race,promise.resolve,promise.rejecr等方法

- async/await
* async/await是写异步代码的新方式，以前的方法有回调函数和Promise。
* async/await是基于Promise实现的，它不能用于普通的回调函数。
* async/await与Promise一样，是非阻塞的。
* async/await使得异步代码看起来像同步代码，这正是它的魔力所在

#### 不同点：
then和settimeout执行顺序，即setTimeout(fn, 0)在下一轮“事件循环”开始时执行，Promise.then()在本轮“事件循环”结束时执行。因此then 函数先输出，settimeout后输出。
例子：
```
var p1 = new Promise(function(resolve, reject){
    resolve(1);
})
setTimeout(function(){
  console.log("will be executed at the top of the next Event Loop");
},0)
p1.then(function(value){
  console.log("p1 fulfilled");
})
setTimeout(function(){
  console.log("will be executed at the bottom of the next Event Loop");
},0)
p1 fulfilled
will be executed at the top of the next Event Loop
will be executed at the bottom of the next Event Loop
```
原因：
> JavaScript将异步任务分为MacroTask和MicroTask，
> * MacroTask包含MacroTask Queue（宏任务队列）主要包括setTimeout,setInterval, setImmediate, requestAnimationFrame, NodeJS中的I/O等。
> * MicroTask包含独立回调microTask：如Promise，其成功／失败回调函数相互独立；复合回调microTask：如 Object.observe, MutationObserver 和NodeJs中的 process.nextTick ，不同状态回调在同一函数体；

- js执行顺序

> * 依次执行同步代码直至执行完毕；
> * 检查MacroTask 队列，若有触发的异步任务，则取第一个并调用其事件处理函数，然后跳至第三步，若没有需处理的异步任务，则直接跳至第三步；
> * 检查MicroTask队列，然后执行所有已触发的异步任务，依次执行事件处理函数，直至执行完毕，然后跳至第二步，若没有需处理的异步任务中，则直接返回第二步，依次>执行后续步骤；
> * 最后返回第二步，继续检查MacroTask队列，依次执行后续步骤；
> * 如此往复，若所有异步任务处理完成，则结束；

promise与asyns/await的不同：
asyns函数前面多了一个aync关键字。await关键字只能用在aync定义的函数内。async函数会隐式地返回一个promise，该promise的reosolve值就是函数return的值。
任何一个await语句后面的 Promise 对象变为reject状态，那么整个async函数都会中断执行

相同点：
async函数的返回值是 Promise 对象，可以使用then方法添加回调函数，这一点与promise类似
希望多个请求并发执行，可以使用Promise.all方法
promise和setTimeout都会被放入任务队列









